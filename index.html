<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo to 3D</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo to 3D">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%232196F3'/><text y='50' x='50' text-anchor='middle' dy='0.35em' fill='white' font-size='40'>3D</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #2196F3;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .photo-section {
            margin-bottom: 30px;
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 300px;
            border: 2px dashed #ddd;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #f9f9f9;
        }

        .photo-container.has-image {
            border: none;
        }

        .photo-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }

        .video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }

        .placeholder {
            text-align: center;
            color: #999;
        }

        .placeholder .icon {
            font-size: 4em;
            margin-bottom: 10px;
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e3f2fd;
            color: #2196F3;
        }

        .btn-secondary:hover {
            background: #bbdefb;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn:disabled:hover {
            transform: none;
        }

        .processing {
            text-align: center;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 12px;
            margin: 20px 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: #2196F3;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .result {
            background: #e8f5e8;
            border: 1px solid #4CAF50;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .result h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .model-preview {
            width: 100%;
            height: 300px;
            border: 2px solid #ddd;
            border-radius: 12px;
            margin: 15px 0;
            background: #f0f0f0;
            position: relative;
            overflow: hidden;
        }

        .preview-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .preview-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preview-btn.active {
            background: #2196F3;
            color: white;
        }

        .preview-btn:not(.active) {
            background: #e3f2fd;
            color: #2196F3;
        }

        .preview-info {
            text-align: left;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .preview-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .file-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .file-info p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .download-btn {
            background: #FF9800;
            color: white;
            margin-top: 15px;
        }

        .download-btn:hover {
            background: #F57C00;
        }

        input[type="file"] {
            display: none;
        }

        .camera-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .photo-container {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì∏ Photo to 3D</h1>
            <p>Turn your photos into 3D printable files</p>
        </div>

        <div class="photo-section">
            <div class="photo-container" id="photoContainer">
                <div class="placeholder" id="placeholder">
                    <div class="icon">üì∑</div>
                    <p>Take a photo or select from library</p>
                </div>
                <img id="photoPreview" class="photo-preview hidden" alt="Selected photo">
                <video id="videoPreview" class="video-preview hidden" autoplay playsinline></video>
            </div>

            <div class="camera-controls hidden" id="cameraControls">
                <button class="btn btn-primary" id="captureBtn">üì∏ Capture</button>
                <button class="btn btn-secondary" id="stopCameraBtn">‚ùå Cancel</button>
            </div>
        </div>

        <div class="buttons">
            <button class="btn btn-primary" id="cameraBtn">üì∑ Take Photo</button>
            <button class="btn btn-secondary" id="libraryBtn">üìÅ Choose from Library</button>
            <button class="btn btn-success hidden" id="processBtn">‚ö° Create 3D Model</button>
            <button class="btn btn-secondary hidden" id="newPhotoBtn">üîÑ Take Another Photo</button>
        </div>

        <div class="processing hidden" id="processing">
            <div class="spinner"></div>
            <h3>Processing your photo...</h3>
            <p id="processingStatus">Analyzing image...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="result hidden" id="result">
            <h3>‚úÖ 3D Model Created!</h3>
            
            <!-- 3D Model Preview -->
            <div class="model-preview" id="modelPreview">
                <div class="preview-loading" id="previewLoading">
                    <div class="spinner"></div>
                    <p>Loading 3D preview...</p>
                </div>
            </div>
            
            <!-- Preview Controls -->
            <div class="preview-controls">
                <button class="preview-btn active" id="wireframeBtn">üî≤ Wireframe</button>
                <button class="preview-btn" id="solidBtn">üéØ Solid</button>
                <button class="preview-btn" id="resetViewBtn">üîÑ Reset View</button>
            </div>
            
            <!-- Model Info -->
            <div class="preview-info">
                <p><strong>üí° 3D Preview Tips:</strong></p>
                <p>‚Ä¢ Drag to rotate ‚Ä¢ Pinch/scroll to zoom ‚Ä¢ Two fingers to pan</p>
                <p>‚Ä¢ Check wireframe to see mesh structure</p>
            </div>
            
            <div class="file-info">
                <p><strong>File:</strong> <span id="fileName">model.stl</span></p>
                <p><strong>Size:</strong> <span id="fileSize">0 KB</span></p>
                <p><strong>Triangles:</strong> <span id="triangleCount">0</span></p>
                <p><strong>Estimated Print Time:</strong> <span id="printTime">0 min</span></p>
            </div>
            <button class="btn download-btn" id="downloadBtn">üíæ Download STL File</button>
        </div>

        <input type="file" id="fileInput" accept="image/*">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class PhotoTo3DApp {
            constructor() {
                this.currentImage = null;
                this.stream = null;
                this.depthModel = null;
                this.canvas = null;
                this.ctx = null;
                this.currentMesh = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.model3D = null;
                this.controls = null;
                this.initializeElements();
                this.bindEvents();
                this.registerServiceWorker();
                this.loadDepthModel();
            }

            initializeElements() {
                this.elements = {
                    photoContainer: document.getElementById('photoContainer'),
                    placeholder: document.getElementById('placeholder'),
                    photoPreview: document.getElementById('photoPreview'),
                    videoPreview: document.getElementById('videoPreview'),
                    cameraControls: document.getElementById('cameraControls'),
                    cameraBtn: document.getElementById('cameraBtn'),
                    libraryBtn: document.getElementById('libraryBtn'),
                    processBtn: document.getElementById('processBtn'),
                    newPhotoBtn: document.getElementById('newPhotoBtn'),
                    captureBtn: document.getElementById('captureBtn'),
                    stopCameraBtn: document.getElementById('stopCameraBtn'),
                    fileInput: document.getElementById('fileInput'),
                    processing: document.getElementById('processing'),
                    processingStatus: document.getElementById('processingStatus'),
                    progressFill: document.getElementById('progressFill'),
                    result: document.getElementById('result'),
                    downloadBtn: document.getElementById('downloadBtn'),
                    fileName: document.getElementById('fileName'),
                    fileSize: document.getElementById('fileSize'),
                    triangleCount: document.getElementById('triangleCount'),
                    printTime: document.getElementById('printTime'),
                    modelPreview: document.getElementById('modelPreview'),
                    previewLoading: document.getElementById('previewLoading'),
                    wireframeBtn: document.getElementById('wireframeBtn'),
                    solidBtn: document.getElementById('solidBtn'),
                    resetViewBtn: document.getElementById('resetViewBtn')
                };
            }

            bindEvents() {
                this.elements.cameraBtn.addEventListener('click', () => this.startCamera());
                this.elements.libraryBtn.addEventListener('click', () => this.elements.fileInput.click());
                this.elements.processBtn.addEventListener('click', () => this.process3DModel());
                this.elements.newPhotoBtn.addEventListener('click', () => this.resetApp());
                this.elements.captureBtn.addEventListener('click', () => this.capturePhoto());
                this.elements.stopCameraBtn.addEventListener('click', () => this.stopCamera());
                this.elements.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.elements.downloadBtn.addEventListener('click', () => this.downloadModel());
                
                // Preview controls
                this.elements.wireframeBtn.addEventListener('click', () => this.setWireframeMode(true));
                this.elements.solidBtn.addEventListener('click', () => this.setWireframeMode(false));
                this.elements.resetViewBtn.addEventListener('click', () => this.resetCamera());
            }

            async loadDepthModel() {
                try {
                    // Note: Using a simple depth estimation approach
                    // In production, you'd use a pre-trained model like MiDaS
                    console.log('Depth estimation ready');
                } catch (error) {
                    console.error('Error loading depth model:', error);
                }
            }

            async startCamera() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    
                    this.elements.videoPreview.srcObject = this.stream;
                    this.elements.placeholder.classList.add('hidden');
                    this.elements.photoPreview.classList.add('hidden');
                    this.elements.videoPreview.classList.remove('hidden');
                    this.elements.cameraControls.classList.remove('hidden');
                    this.elements.cameraBtn.classList.add('hidden');
                    this.elements.libraryBtn.classList.add('hidden');
                } catch (error) {
                    alert('Camera access denied or not available');
                }
            }

            capturePhoto() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const video = this.elements.videoPreview;
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob((blob) => {
                    this.displayCapturedImage(blob);
                    this.stopCamera();
                });
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.elements.videoPreview.classList.add('hidden');
                this.elements.cameraControls.classList.add('hidden');
                this.elements.cameraBtn.classList.remove('hidden');
                this.elements.libraryBtn.classList.remove('hidden');
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    this.displayCapturedImage(file);
                }
            }

            displayCapturedImage(imageFile) {
                const url = URL.createObjectURL(imageFile);
                this.currentImage = imageFile;
                
                this.elements.photoPreview.src = url;
                this.elements.photoPreview.classList.remove('hidden');
                this.elements.placeholder.classList.add('hidden');
                this.elements.photoContainer.classList.add('has-image');
                
                this.elements.processBtn.classList.remove('hidden');
                this.elements.newPhotoBtn.classList.remove('hidden');
            }

            async process3DModel() {
                this.elements.processing.classList.remove('hidden');
                this.elements.processBtn.disabled = true;
                
                try {
                    // Step 1: Prepare image
                    await this.updateProgress('Preparing image...', 10);
                    const imageData = await this.prepareImageForProcessing();
                    
                    if (!imageData || !imageData.data) {
                        throw new Error('Failed to prepare image data');
                    }
                    
                    // Step 2: Estimate depth
                    await this.updateProgress('Analyzing depth information...', 30);
                    const depthMap = await this.estimateDepth(imageData);
                    
                    if (!depthMap || depthMap.length === 0) {
                        throw new Error('Failed to estimate depth');
                    }
                    
                    // Step 3: Generate point cloud
                    await this.updateProgress('Creating 3D point cloud...', 50);
                    const pointCloud = this.generatePointCloud(imageData, depthMap);
                    
                    if (!pointCloud || pointCloud.length === 0) {
                        throw new Error('Failed to generate point cloud');
                    }
                    
                    // Step 4: Create mesh
                    await this.updateProgress('Generating mesh...', 70);
                    const mesh = this.createMeshFromPointCloud(pointCloud);
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Failed to create mesh');
                    }
                    
                    // Step 5: Optimize for 3D printing
                    await this.updateProgress('Optimizing for 3D printing...', 85);
                    const optimizedMesh = this.optimizeForPrinting(mesh);
                    
                    if (!optimizedMesh || !optimizedMesh.vertices || !optimizedMesh.faces) {
                        throw new Error('Failed to optimize mesh');
                    }
                    
                    // Step 6: Generate STL
                    await this.updateProgress('Creating STL file...', 95);
                    const stlContent = this.generateAdvancedSTL(optimizedMesh);
                    
                    if (!stlContent) {
                        throw new Error('Failed to generate STL');
                    }
                    
                    await this.updateProgress('Complete!', 100);
                    this.finalize3DModel(stlContent);
                    
                } catch (error) {
                    console.error('Processing error details:', error);
                    console.error('Error stack:', error.stack);
                    alert(`Error processing image: ${error.message}. Please try another photo.`);
                    this.elements.processing.classList.add('hidden');
                    this.elements.processBtn.disabled = false;
                }
            }

            async updateProgress(status, progress) {
                this.elements.processingStatus.textContent = status;
                this.elements.progressFill.style.width = progress + '%';
                await this.delay(800); // Realistic processing time
            }

            async prepareImageForProcessing() {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = this.elements.photoPreview;
                    
                    // Resize image for processing (smaller = faster)
                    const maxSize = 512;
                    let { width, height } = img;
                    
                    if (width > height) {
                        if (width > maxSize) {
                            height = (height * maxSize) / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = (width * maxSize) / height;
                            height = maxSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    const imageData = ctx.getImageData(0, 0, width, height);
                    resolve({ data: imageData, width, height });
                });
            }

            async estimateDepth(imageData) {
                // Advanced depth estimation using image analysis
                const { data, width, height } = imageData;
                const depthMap = new Float32Array(width * height);
                
                // Convert to grayscale and analyze brightness patterns
                for (let i = 0; i < data.data.length; i += 4) {
                    const pixelIndex = i / 4;
                    const r = data.data[i];
                    const g = data.data[i + 1];
                    const b = data.data[i + 2];
                    
                    // Convert to grayscale
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    // Basic depth estimation: darker = closer, lighter = farther
                    // In real app, this would use ML model
                    let depth = (255 - gray) / 255.0;
                    
                    // Add some noise and variation for more realistic depth
                    const x = pixelIndex % width;
                    const y = Math.floor(pixelIndex / width);
                    
                    // Edge detection for depth discontinuities
                    if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                        const neighbors = [
                            data.data[(pixelIndex - width) * 4], // top
                            data.data[(pixelIndex + width) * 4], // bottom
                            data.data[(pixelIndex - 1) * 4],     // left
                            data.data[(pixelIndex + 1) * 4]      // right
                        ];
                        
                        const variance = this.calculateVariance(neighbors);
                        if (variance > 50) { // Edge detected
                            depth += 0.2; // Edges are typically closer
                        }
                    }
                    
                    // Smooth depth transitions
                    depth = Math.max(0.1, Math.min(1.0, depth));
                    depthMap[pixelIndex] = depth;
                }
                
                // Apply smoothing filter
                return this.smoothDepthMap(depthMap, width, height);
            }

            calculateVariance(values) {
                const mean = values.reduce((a, b) => a + b) / values.length;
                return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            }

            smoothDepthMap(depthMap, width, height) {
                const smoothed = new Float32Array(depthMap.length);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        // 3x3 average filter
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += depthMap[(y + dy) * width + (x + dx)];
                            }
                        }
                        smoothed[idx] = sum / 9;
                    }
                }
                
                return smoothed;
            }

            generatePointCloud(imageData, depthMap) {
                const { width, height } = imageData;
                const points = [];
                
                // Generate 3D points from depth map
                for (let y = 0; y < height; y += 2) { // Skip pixels for performance
                    for (let x = 0; x < width; x += 2) {
                        const idx = y * width + x;
                        const depth = depthMap[idx];
                        
                        // Convert 2D coordinates to 3D
                        const worldX = (x - width / 2) / width * 20; // Scale to reasonable size
                        const worldY = (height / 2 - y) / height * 20;
                        const worldZ = depth * 10; // Height based on depth
                        
                        // Get color from original image
                        const pixelIdx = idx * 4;
                        const r = imageData.data.data[pixelIdx];
                        const g = imageData.data.data[pixelIdx + 1];
                        const b = imageData.data.data[pixelIdx + 2];
                        
                        points.push({
                            x: worldX,
                            y: worldY,
                            z: worldZ,
                            color: { r, g, b }
                        });
                    }
                }
                
                return points;
            }

            createMeshFromPointCloud(pointCloud) {
                try {
                    const vertices = [];
                    const faces = [];
                    
                    // Determine grid dimensions
                    const totalPoints = pointCloud.length;
                    const gridWidth = Math.floor(Math.sqrt(totalPoints));
                    const gridHeight = Math.floor(totalPoints / gridWidth);
                    
                    console.log(`Creating mesh: ${totalPoints} points, ${gridWidth}x${gridHeight} grid`);
                    
                    // Add all vertices
                    pointCloud.forEach(point => {
                        vertices.push({
                            x: point.x,
                            y: point.y,
                            z: point.z,
                            color: point.color
                        });
                    });
                    
                    // Create triangular faces
                    for (let row = 0; row < gridHeight - 1; row++) {
                        for (let col = 0; col < gridWidth - 1; col++) {
                            const i = row * gridWidth + col;
                            
                            // Skip if indices are out of bounds
                            if (i + gridWidth + 1 >= vertices.length) continue;
                            
                            const topLeft = i;
                            const topRight = i + 1;
                            const bottomLeft = i + gridWidth;
                            const bottomRight = i + gridWidth + 1;
                            
                            // Ensure all indices are valid
                            if (topLeft < vertices.length && 
                                topRight < vertices.length && 
                                bottomLeft < vertices.length && 
                                bottomRight < vertices.length) {
                                
                                // Create two triangles per quad
                                faces.push([topLeft, topRight, bottomLeft]);
                                faces.push([topRight, bottomRight, bottomLeft]);
                            }
                        }
                    }
                    
                    console.log(`Mesh created: ${vertices.length} vertices, ${faces.length} faces`);
                    
                    if (vertices.length === 0 || faces.length === 0) {
                        throw new Error('No valid mesh geometry created');
                    }
                    
                    return { vertices, faces };
                    
                } catch (error) {
                    console.error('Error in createMeshFromPointCloud:', error);
                    throw error;
                }
            }

            optimizeForPrinting(mesh) {
                try {
                    console.log('Starting optimization...');
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Invalid mesh data for optimization');
                    }
                    
                    // Store the mesh for 3D preview (before adding base)
                    this.currentMesh = {
                        vertices: [...mesh.vertices], // Create copy
                        faces: [...mesh.faces] // Create copy
                    };
                    
                    // Add base thickness for printability
                    const baseThickness = 2.0;
                    const optimizedVertices = [];
                    
                    // Find minimum Z value
                    const zValues = mesh.vertices.map(v => v.z).filter(z => !isNaN(z));
                    if (zValues.length === 0) {
                        throw new Error('No valid Z coordinates found');
                    }
                    
                    const minZ = Math.min(...zValues);
                    console.log(`Min Z value: ${minZ}`);
                    
                    // Adjust all vertices and add base
                    mesh.vertices.forEach((vertex, index) => {
                        if (!vertex || typeof vertex.x !== 'number' || typeof vertex.y !== 'number' || typeof vertex.z !== 'number') {
                            console.warn(`Invalid vertex at index ${index}:`, vertex);
                            return; // Skip invalid vertices
                        }
                        
                        // Elevate surface
                        optimizedVertices.push({
                            x: vertex.x,
                            y: vertex.y,
                            z: vertex.z - minZ + baseThickness,
                            color: vertex.color || { r: 128, g: 128, b: 128 }
                        });
                    });
                    
                    // Add base vertices
                    mesh.vertices.forEach((vertex, index) => {
                        if (!vertex || typeof vertex.x !== 'number' || typeof vertex.y !== 'number' || typeof vertex.z !== 'number') {
                            return; // Skip invalid vertices
                        }
                        
                        optimizedVertices.push({
                            x: vertex.x,
                            y: vertex.y,
                            z: 0,
                            color: vertex.color || { r: 128, g: 128, b: 128 }
                        });
                    });
                    
                    // Copy original faces
                    const optimizedFaces = [...mesh.faces];
                    const validVertexCount = mesh.vertices.filter(v => v && typeof v.x === 'number').length;
                    
                    // Add base faces (flipped normals) - only if we have valid vertices
                    if (validVertexCount > 0) {
                        mesh.faces.forEach(face => {
                            if (face && Array.isArray(face) && face.length === 3) {
                                // Check if face indices are valid
                                if (face[0] < validVertexCount && face[1] < validVertexCount && face[2] < validVertexCount) {
                                    optimizedFaces.push([
                                        face[0] + validVertexCount,
                                        face[2] + validVertexCount,
                                        face[1] + validVertexCount
                                    ]);
                                }
                            }
                        });
                    }
                    
                    const result = {
                        vertices: optimizedVertices,
                        faces: optimizedFaces
                    };
                    
                    console.log(`Optimization complete: ${result.vertices.length} vertices, ${result.faces.length} faces`);
                    
                    if (result.vertices.length === 0 || result.faces.length === 0) {
                        throw new Error('Optimization resulted in empty mesh');
                    }
                    
                    return result;
                    
                } catch (error) {
                    console.error('Error in optimizeForPrinting:', error);
                    throw error;
                }
            }

            generateAdvancedSTL(mesh) {
                try {
                    console.log('Generating STL...');
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Invalid mesh data for STL generation');
                    }
                    
                    let stl = 'solid PhotoTo3DModel\n';
                    let validFaceCount = 0;
                    
                    mesh.faces.forEach((face, faceIndex) => {
                        try {
                            if (!face || !Array.isArray(face) || face.length !== 3) {
                                console.warn(`Invalid face at index ${faceIndex}:`, face);
                                return;
                            }
                            
                            const [i1, i2, i3] = face;
                            
                            // Check if vertex indices are valid
                            if (i1 >= mesh.vertices.length || i2 >= mesh.vertices.length || i3 >= mesh.vertices.length ||
                                i1 < 0 || i2 < 0 || i3 < 0) {
                                console.warn(`Invalid vertex indices in face ${faceIndex}: [${i1}, ${i2}, ${i3}]`);
                                return;
                            }
                            
                            const v1 = mesh.vertices[i1];
                            const v2 = mesh.vertices[i2];
                            const v3 = mesh.vertices[i3];
                            
                            // Validate vertices
                            if (!v1 || !v2 || !v3 ||
                                typeof v1.x !== 'number' || typeof v1.y !== 'number' || typeof v1.z !== 'number' ||
                                typeof v2.x !== 'number' || typeof v2.y !== 'number' || typeof v2.z !== 'number' ||
                                typeof v3.x !== 'number' || typeof v3.y !== 'number' || typeof v3.z !== 'number') {
                                console.warn(`Invalid vertices in face ${faceIndex}:`, { v1, v2, v3 });
                                return;
                            }
                            
                            // Calculate normal vector
                            const normal = this.calculateNormal(v1, v2, v3);
                            
                            // Validate normal
                            if (!normal || typeof normal.x !== 'number' || typeof normal.y !== 'number' || typeof normal.z !== 'number') {
                                console.warn(`Invalid normal for face ${faceIndex}:`, normal);
                                return;
                            }
                            
                            stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                            stl += '    outer loop\n';
                            stl += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                            stl += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                            stl += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                            stl += '    endloop\n';
                            stl += '  endfacet\n';
                            
                            validFaceCount++;
                            
                        } catch (faceError) {
                            console.warn(`Error processing face ${faceIndex}:`, faceError);
                        }
                    });
                    
                    stl += 'endsolid PhotoTo3DModel\n';
                    
                    console.log(`STL generated with ${validFaceCount} valid faces`);
                    
                    if (validFaceCount === 0) {
                        throw new Error('No valid faces generated in STL');
                    }
                    
                    return stl;
                    
                } catch (error) {
                    console.error('Error in generateAdvancedSTL:', error);
                    throw error;
                }
            }

            calculateNormal(v1, v2, v3) {
                try {
                    // Calculate cross product for normal vector
                    const u = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
                    const v = { x: v3.x - v1.x, y: v3.y - v1.y, z: v3.z - v1.z };
                    
                    const normal = {
                        x: u.y * v.z - u.z * v.y,
                        y: u.z * v.x - u.x * v.z,
                        z: u.x * v.y - u.y * v.x
                    };
                    
                    // Normalize
                    const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (length > 0.0001) { // Avoid division by very small numbers
                        normal.x /= length;
                        normal.y /= length;
                        normal.z /= length;
                    } else {
                        // Default normal if calculation fails
                        normal.x = 0;
                        normal.y = 0;
                        normal.z = 1;
                    }
                    
                    // Ensure normal values are valid numbers
                    if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)) {
                        return { x: 0, y: 0, z: 1 }; // Default normal
                    }
                    
                    return normal;
                    
                } catch (error) {
                    console.warn('Error calculating normal:', error);
                    return { x: 0, y: 0, z: 1 }; // Default normal
                }
            }

            finalize3DModel(stlContent) {
                const blob = new Blob([stlContent], { type: 'application/octet-stream' });
                this.modelBlob = blob;
                
                // Calculate realistic metrics
                const triangleCount = (stlContent.match(/facet normal/g) || []).length;
                const fileSize = Math.round(blob.size / 1024);
                const printTime = Math.max(30, Math.floor(triangleCount / 50)); // More realistic print time
                const fileName = `photo_3d_${Date.now()}.stl`;
                
                this.elements.fileName.textContent = fileName;
                this.elements.fileSize.textContent = fileSize + ' KB';
                this.elements.triangleCount.textContent = triangleCount.toLocaleString();
                this.elements.printTime.textContent = printTime + ' min';
                
                this.elements.processing.classList.add('hidden');
                this.elements.result.classList.remove('hidden');
                this.elements.processBtn.disabled = false;
                
                // Initialize 3D preview
                this.init3DPreview();
            }

            init3DPreview() {
                const container = this.elements.modelPreview;
                
                // Clear previous preview
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                
                // Create Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    container.clientWidth / container.clientHeight, 
                    0.1, 
                    1000
                );
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);
                
                // Add lights
                this.addLights();
                
                // Create 3D model from mesh data
                this.create3DModel();
                
                // Add controls
                this.addOrbitControls();
                
                // Position camera
                this.resetCamera();
                
                // Start render loop
                this.animate();
                
                // Hide loading indicator
                this.elements.previewLoading.style.display = 'none';
            }

            addLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (main)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                
                // Point light (fill)
                const pointLight = new THREE.PointLight(0xffffff, 0.3, 100);
                pointLight.position.set(-10, -10, 10);
                this.scene.add(pointLight);
            }

            create3DModel() {
                if (!this.currentMesh) return;
                
                // Create geometry from mesh data
                const geometry = new THREE.BufferGeometry();
                
                // Convert vertices to flat array
                const vertices = [];
                const normals = [];
                
                this.currentMesh.faces.forEach(face => {
                    const v1 = this.currentMesh.vertices[face[0]];
                    const v2 = this.currentMesh.vertices[face[1]];
                    const v3 = this.currentMesh.vertices[face[2]];
                    
                    // Add vertices
                    vertices.push(v1.x, v1.y, v1.z);
                    vertices.push(v2.x, v2.y, v2.z);
                    vertices.push(v3.x, v3.y, v3.z);
                    
                    // Calculate normal
                    const normal = this.calculateNormal(v1, v2, v3);
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                // Create materials
                const solidMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4CAF50,
                    side: THREE.DoubleSide
                });
                
                const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x2196F3,
                    wireframe: true,
                    side: THREE.DoubleSide
                });
                
                // Create mesh
                this.model3D = new THREE.Mesh(geometry, solidMaterial);
                this.model3D.castShadow = true;
                this.model3D.receiveShadow = true;
                
                // Store materials for switching
                this.model3D.userData.solidMaterial = solidMaterial;
                this.model3D.userData.wireframeMaterial = wireframeMaterial;
                
                this.scene.add(this.model3D);
                
                // Add ground plane
                this.addGroundPlane();
            }

            addGroundPlane() {
                const planeGeometry = new THREE.PlaneGeometry(50, 50);
                const planeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.3
                });
                
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -5;
                plane.receiveShadow = true;
                
                this.scene.add(plane);
            }

            addOrbitControls() {
                // Simple orbit controls implementation
                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                let targetRotationX = 0;
                let targetRotationY = 0;
                let rotationX = 0;
                let rotationY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                // Touch controls for mobile
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        isMouseDown = true;
                        mouseX = e.touches[0].clientX;
                        mouseY = e.touches[0].clientY;
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (!isMouseDown || e.touches.length !== 1) return;
                    e.preventDefault();
                    
                    const deltaX = e.touches[0].clientX - mouseX;
                    const deltaY = e.touches[0].clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                });
                
                canvas.addEventListener('touchend', () => {
                    isMouseDown = false;
                });
                
                // Zoom with wheel/pinch
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoom = e.deltaY * 0.01;
                    this.camera.position.z = Math.max(5, Math.min(50, this.camera.position.z + zoom));
                });
                
                // Store rotation update function
                this.updateRotation = () => {
                    rotationX += (targetRotationX - rotationX) * 0.1;
                    rotationY += (targetRotationY - rotationY) * 0.1;
                    
                    if (this.model3D) {
                        this.model3D.rotation.x = rotationX;
                        this.model3D.rotation.y = rotationY;
                    }
                };
            }

            animate() {
                if (!this.renderer || !this.scene || !this.camera) return;
                
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                if (this.updateRotation) {
                    this.updateRotation();
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            setWireframeMode(wireframe) {
                if (!this.model3D) return;
                
                if (wireframe) {
                    this.model3D.material = this.model3D.userData.wireframeMaterial;
                    this.elements.wireframeBtn.classList.add('active');
                    this.elements.solidBtn.classList.remove('active');
                } else {
                    this.model3D.material = this.model3D.userData.solidMaterial;
                    this.elements.wireframeBtn.classList.remove('active');
                    this.elements.solidBtn.classList.add('active');
                }
            }

            resetCamera() {
                if (!this.camera) return;
                
                this.camera.position.set(15, 15, 15);
                this.camera.lookAt(0, 0, 0);
                
                if (this.model3D) {
                    this.model3D.rotation.x = 0.3;
                    this.model3D.rotation.y = 0.5;
                }
            }

            generate3DFile() {
                // This method is now replaced by the advanced processing above
                // Keeping for backwards compatibility if needed
            }

            generateSTLContent() {
                // Generate a simple pyramid STL for demo
                // In a real app, this would be the actual 3D reconstruction
                let stl = 'solid PhotoTo3DModel\n';
                
                // Simple pyramid faces
                const faces = [
                    // Base
                    [[0, 0, 0], [10, 0, 0], [5, 10, 0]],
                    [[0, 0, 0], [5, 10, 0], [10, 0, 0]],
                    // Sides
                    [[0, 0, 0], [5, 5, 10], [10, 0, 0]],
                    [[10, 0, 0], [5, 5, 10], [5, 10, 0]],
                    [[5, 10, 0], [5, 5, 10], [0, 0, 0]]
                ];
                
                faces.forEach(face => {
                    stl += '  facet normal 0 0 1\n';
                    stl += '    outer loop\n';
                    face.forEach(vertex => {
                        stl += `      vertex ${vertex[0]} ${vertex[1]} ${vertex[2]}\n`;
                    });
                    stl += '    endloop\n';
                    stl += '  endfacet\n';
                });
                
                stl += 'endsolid PhotoTo3DModel\n';
                return stl;
            }

            downloadModel() {
                if (this.modelBlob) {
                    const url = URL.createObjectURL(this.modelBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.elements.fileName.textContent;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            resetApp() {
                this.currentImage = null;
                this.modelBlob = null;
                this.currentMesh = null;
                
                // Clean up 3D scene
                if (this.renderer) {
                    this.renderer.dispose();
                    this.renderer = null;
                }
                this.scene = null;
                this.camera = null;
                this.model3D = null;
                
                this.elements.photoPreview.classList.add('hidden');
                this.elements.placeholder.classList.remove('hidden');
                this.elements.photoContainer.classList.remove('has-image');
                this.elements.processBtn.classList.add('hidden');
                this.elements.newPhotoBtn.classList.add('hidden');
                this.elements.processing.classList.add('hidden');
                this.elements.result.classList.add('hidden');
                this.elements.progressFill.style.width = '0%';
                this.elements.fileInput.value = '';
                this.elements.previewLoading.style.display = 'block';
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker registered:', registration);
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new PhotoTo3DApp();
        });

        // Add to home screen prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button after a delay
            setTimeout(() => {
                if (confirm('Add Photo to 3D to your home screen for easy access?')) {
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then((choiceResult) => {
                        deferredPrompt = null;
                    });
                }
            }, 3000);
        });
    </script>
</body>
</html>
