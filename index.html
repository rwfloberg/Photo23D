<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo to 3D</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Photo to 3D">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%232196F3'/><text y='50' x='50' text-anchor='middle' dy='0.35em' fill='white' font-size='40'>3D</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #2196F3;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .photo-section {
            margin-bottom: 30px;
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 300px;
            border: 2px dashed #ddd;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #f9f9f9;
        }

        .photo-container.has-image {
            border: none;
        }

        .photo-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }

        .video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }

        .placeholder {
            text-align: center;
            color: #999;
        }

        .placeholder .icon {
            font-size: 4em;
            margin-bottom: 10px;
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e3f2fd;
            color: #2196F3;
        }

        .btn-secondary:hover {
            background: #bbdefb;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn:disabled:hover {
            transform: none;
        }

        .processing {
            text-align: center;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 12px;
            margin: 20px 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: #2196F3;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .result {
            background: #e8f5e8;
            border: 1px solid #4CAF50;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .result h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .model-preview {
            width: 100%;
            height: 300px;
            border: 2px solid #ddd;
            border-radius: 12px;
            margin: 15px 0;
            background: #f0f0f0;
            position: relative;
            overflow: hidden;
        }

        .preview-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .preview-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preview-btn.active {
            background: #2196F3;
            color: white;
        }

        .preview-btn:not(.active) {
            background: #e3f2fd;
            color: #2196F3;
        }

        .preview-info {
            text-align: left;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .preview-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .file-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .file-info p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .download-btn {
            background: #FF9800;
            color: white;
            margin-top: 15px;
        }

        .download-btn:hover {
            background: #F57C00;
        }

        input[type="file"] {
            display: none;
        }

        .camera-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .hidden {
            display: none;
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #ffffff;
            font-weight: bold;
        }

        .debug-toggle {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
        }

        .debug-content {
            max-height: 300px;
            overflow-y: auto;
        }

        .debug-log {
            margin: 5px 0;
            padding: 3px 5px;
            border-radius: 3px;
        }

        .debug-log.error {
            background: rgba(255, 0, 0, 0.2);
            color: #ff9999;
        }

        .debug-log.warning {
            background: rgba(255, 165, 0, 0.2);
            color: #ffcc99;
        }

        .debug-log.info {
            background: rgba(0, 255, 0, 0.1);
            color: #99ff99;
        }

        .debug-log.step {
            background: rgba(0, 150, 255, 0.2);
            color: #99ccff;
        }

        .debug-stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            margin: 8px 0;
            border-radius: 4px;
            color: #cccccc;
        }

        .debug-fab {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 999;
        }

        @media (max-width: 600px) {
            .debug-panel {
                width: calc(100vw - 40px);
                right: 20px;
                left: 20px;
                bottom: 90px;
            }
            
            .debug-fab {
                bottom: 20px;
                right: 20px;
            }
        }

        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .photo-container {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì∏ Photo to 3D</h1>
            <p>Turn your photos into 3D printable files</p>
        </div>

        <div class="photo-section">
            <div class="photo-container" id="photoContainer">
                <div class="placeholder" id="placeholder">
                    <div class="icon">üì∑</div>
                    <p>Take a photo or select from library</p>
                </div>
                <img id="photoPreview" class="photo-preview hidden" alt="Selected photo">
                <video id="videoPreview" class="video-preview hidden" autoplay playsinline></video>
            </div>

            <div class="camera-controls hidden" id="cameraControls">
                <button class="btn btn-primary" id="captureBtn">üì∏ Capture</button>
                <button class="btn btn-secondary" id="stopCameraBtn">‚ùå Cancel</button>
            </div>
        </div>

        <div class="buttons">
            <button class="btn btn-primary" id="cameraBtn">üì∑ Take Photo</button>
            <button class="btn btn-secondary" id="libraryBtn">üìÅ Choose from Library</button>
            <button class="btn btn-success hidden" id="processBtn">‚ö° Create 3D Model</button>
            <button class="btn btn-secondary hidden" id="newPhotoBtn">üîÑ Take Another Photo</button>
        </div>

        <div class="processing hidden" id="processing">
            <div class="spinner"></div>
            <h3>Processing your photo...</h3>
            <p id="processingStatus">Analyzing image...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="result hidden" id="result">
            <h3>‚úÖ 3D Model Created!</h3>
            
            <!-- 3D Model Preview -->
            <div class="model-preview" id="modelPreview">
                <div class="preview-loading" id="previewLoading">
                    <div class="spinner"></div>
                    <p>Loading 3D preview...</p>
                </div>
            </div>
            
            <!-- Preview Controls -->
            <div class="preview-controls">
                <button class="preview-btn active" id="wireframeBtn">üî≤ Wireframe</button>
                <button class="preview-btn" id="solidBtn">üéØ Solid</button>
                <button class="preview-btn" id="resetViewBtn">üîÑ Reset View</button>
            </div>
            
            <!-- Model Info -->
            <div class="preview-info">
                <p><strong>üí° 3D Preview Tips:</strong></p>
                <p>‚Ä¢ Drag to rotate ‚Ä¢ Pinch/scroll to zoom ‚Ä¢ Two fingers to pan</p>
                <p>‚Ä¢ Check wireframe to see mesh structure</p>
            </div>
            
            <div class="file-info">
                <p><strong>File:</strong> <span id="fileName">model.stl</span></p>
                <p><strong>Size:</strong> <span id="fileSize">0 KB</span></p>
                <p><strong>Triangles:</strong> <span id="triangleCount">0</span></p>
                <p><strong>Estimated Print Time:</strong> <span id="printTime">0 min</span></p>
            </div>
            <button class="btn download-btn" id="downloadBtn">üíæ Download STL File</button>
        </div>

        <input type="file" id="fileInput" accept="image/*">
    </div>

    <!-- Debug Panel -->
    <button class="debug-fab" id="debugFab">üêõ</button>
    <div class="debug-panel hidden" id="debugPanel">
        <div class="debug-header">
            <span>üêõ Debug Console</span>
            <button class="debug-toggle" id="debugClose">‚úï</button>
        </div>
        <div class="debug-stats" id="debugStats">
            <div>Status: Ready</div>
            <div>Memory: --</div>
            <div>Performance: --</div>
        </div>
        <div class="debug-content" id="debugContent">
            <div class="debug-log info">Debug panel initialized</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class PhotoTo3DApp {
            constructor() {
                this.currentImage = null;
                this.stream = null;
                this.depthModel = null;
                this.canvas = null;
                this.ctx = null;
                this.currentMesh = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.model3D = null;
                this.controls = null;
                this.debugLogs = [];
                this.initializeElements();
                this.bindEvents();
                this.registerServiceWorker();
                this.loadDepthModel();
                this.initDebugPanel();
            }

            initializeElements() {
                this.elements = {
                    photoContainer: document.getElementById('photoContainer'),
                    placeholder: document.getElementById('placeholder'),
                    photoPreview: document.getElementById('photoPreview'),
                    videoPreview: document.getElementById('videoPreview'),
                    cameraControls: document.getElementById('cameraControls'),
                    cameraBtn: document.getElementById('cameraBtn'),
                    libraryBtn: document.getElementById('libraryBtn'),
                    processBtn: document.getElementById('processBtn'),
                    newPhotoBtn: document.getElementById('newPhotoBtn'),
                    captureBtn: document.getElementById('captureBtn'),
                    stopCameraBtn: document.getElementById('stopCameraBtn'),
                    fileInput: document.getElementById('fileInput'),
                    processing: document.getElementById('processing'),
                    processingStatus: document.getElementById('processingStatus'),
                    progressFill: document.getElementById('progressFill'),
                    result: document.getElementById('result'),
                    downloadBtn: document.getElementById('downloadBtn'),
                    fileName: document.getElementById('fileName'),
                    fileSize: document.getElementById('fileSize'),
                    triangleCount: document.getElementById('triangleCount'),
                    printTime: document.getElementById('printTime'),
                    modelPreview: document.getElementById('modelPreview'),
                    previewLoading: document.getElementById('previewLoading'),
                    wireframeBtn: document.getElementById('wireframeBtn'),
                    solidBtn: document.getElementById('solidBtn'),
                    resetViewBtn: document.getElementById('resetViewBtn'),
                    debugFab: document.getElementById('debugFab'),
                    debugPanel: document.getElementById('debugPanel'),
                    debugClose: document.getElementById('debugClose'),
                    debugContent: document.getElementById('debugContent'),
                    debugStats: document.getElementById('debugStats')
                };
            }

            bindEvents() {
                this.elements.cameraBtn.addEventListener('click', () => this.startCamera());
                this.elements.libraryBtn.addEventListener('click', () => this.elements.fileInput.click());
                this.elements.processBtn.addEventListener('click', () => this.process3DModel());
                this.elements.newPhotoBtn.addEventListener('click', () => this.resetApp());
                this.elements.captureBtn.addEventListener('click', () => this.capturePhoto());
                this.elements.stopCameraBtn.addEventListener('click', () => this.stopCamera());
                this.elements.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.elements.downloadBtn.addEventListener('click', () => this.downloadModel());
                
                // Preview controls
                this.elements.wireframeBtn.addEventListener('click', () => this.setWireframeMode(true));
                this.elements.solidBtn.addEventListener('click', () => this.setWireframeMode(false));
                this.elements.resetViewBtn.addEventListener('click', () => this.resetCamera());
                
                // Debug panel controls
                this.elements.debugFab.addEventListener('click', () => this.toggleDebugPanel());
                this.elements.debugClose.addEventListener('click', () => this.toggleDebugPanel());
            }

            initDebugPanel() {
                this.debugLog('Debug panel initialized', 'info');
                this.updateDebugStats('Ready', '--', '--');
                
                // Override console methods to capture logs
                const originalConsoleLog = console.log;
                const originalConsoleError = console.error;
                const originalConsoleWarn = console.warn;
                
                console.log = (...args) => {
                    originalConsoleLog.apply(console, args);
                    this.debugLog(args.join(' '), 'info');
                };
                
                console.error = (...args) => {
                    originalConsoleError.apply(console, args);
                    this.debugLog(args.join(' '), 'error');
                };
                
                console.warn = (...args) => {
                    originalConsoleWarn.apply(console, args);
                    this.debugLog(args.join(' '), 'warning');
                };
                
                // Capture unhandled errors
                window.addEventListener('error', (e) => {
                    this.debugLog(`ERROR: ${e.message} at ${e.filename}:${e.lineno}`, 'error');
                });
                
                // Monitor memory usage
                setInterval(() => {
                    if (performance.memory) {
                        const memory = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1) + 'MB';
                        this.updateMemoryStats(memory);
                    }
                }, 2000);
            }

            debugLog(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    time: timestamp,
                    message: message,
                    type: type
                };
                
                this.debugLogs.push(logEntry);
                
                // Keep only last 50 logs
                if (this.debugLogs.length > 50) {
                    this.debugLogs.shift();
                }
                
                this.updateDebugDisplay();
            }

            updateDebugDisplay() {
                const content = this.elements.debugContent;
                content.innerHTML = '';
                
                this.debugLogs.forEach(log => {
                    const div = document.createElement('div');
                    div.className = `debug-log ${log.type}`;
                    div.innerHTML = `<span style="color: #666;">${log.time}</span> ${log.message}`;
                    content.appendChild(div);
                });
                
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
            }

            updateDebugStats(status, memory, performance) {
                const stats = this.elements.debugStats;
                stats.innerHTML = `
                    <div>Status: ${status}</div>
                    <div>Memory: ${memory}</div>
                    <div>Performance: ${performance}</div>
                `;
            }

            updateMemoryStats(memory) {
                const currentStats = this.elements.debugStats.innerHTML;
                const updatedStats = currentStats.replace(/Memory: [^<]*/, `Memory: ${memory}`);
                this.elements.debugStats.innerHTML = updatedStats;
            }

            toggleDebugPanel() {
                this.elements.debugPanel.classList.toggle('hidden');
            }

            async loadDepthModel() {
                try {
                    // Note: Using a simple depth estimation approach
                    // In production, you'd use a pre-trained model like MiDaS
                    console.log('Depth estimation ready');
                } catch (error) {
                    console.error('Error loading depth model:', error);
                }
            }

            async startCamera() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    
                    this.elements.videoPreview.srcObject = this.stream;
                    this.elements.placeholder.classList.add('hidden');
                    this.elements.photoPreview.classList.add('hidden');
                    this.elements.videoPreview.classList.remove('hidden');
                    this.elements.cameraControls.classList.remove('hidden');
                    this.elements.cameraBtn.classList.add('hidden');
                    this.elements.libraryBtn.classList.add('hidden');
                } catch (error) {
                    alert('Camera access denied or not available');
                }
            }

            capturePhoto() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const video = this.elements.videoPreview;
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob((blob) => {
                    this.displayCapturedImage(blob);
                    this.stopCamera();
                });
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.elements.videoPreview.classList.add('hidden');
                this.elements.cameraControls.classList.add('hidden');
                this.elements.cameraBtn.classList.remove('hidden');
                this.elements.libraryBtn.classList.remove('hidden');
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    this.displayCapturedImage(file);
                }
            }

            displayCapturedImage(imageFile) {
                const url = URL.createObjectURL(imageFile);
                this.currentImage = imageFile;
                
                this.elements.photoPreview.src = url;
                this.elements.photoPreview.classList.remove('hidden');
                this.elements.placeholder.classList.add('hidden');
                this.elements.photoContainer.classList.add('has-image');
                
                this.elements.processBtn.classList.remove('hidden');
                this.elements.newPhotoBtn.classList.remove('hidden');
            }

            async process3DModel() {
                this.elements.processing.classList.remove('hidden');
                this.elements.processBtn.disabled = true;
                this.debugLog('üöÄ Starting 3D model processing', 'step');
                this.updateDebugStats('Processing', '--', '--');
                
                const startTime = performance.now();
                
                try {
                    // Step 1: Prepare image
                    await this.updateProgress('Preparing image...', 10);
                    this.debugLog('üì∑ Preparing image for processing', 'step');
                    const imageData = await this.prepareImageForProcessing();
                    
                    if (!imageData || !imageData.data) {
                        throw new Error('Failed to prepare image data');
                    }
                    this.debugLog(`‚úÖ Image prepared: ${imageData.width}x${imageData.height}`, 'info');
                    
                    // Step 2: Estimate depth
                    await this.updateProgress('Analyzing depth information...', 30);
                    this.debugLog('üîç Estimating depth from image', 'step');
                    const depthMap = await this.estimateDepth(imageData);
                    
                    if (!depthMap || depthMap.length === 0) {
                        throw new Error('Failed to estimate depth');
                    }
                    this.debugLog(`‚úÖ Depth map created: ${depthMap.length} points`, 'info');
                    
                    // Step 3: Generate point cloud
                    await this.updateProgress('Creating 3D point cloud...', 50);
                    this.debugLog('‚òÅÔ∏è Generating 3D point cloud', 'step');
                    const pointCloud = this.generatePointCloud(imageData, depthMap);
                    
                    if (!pointCloud || pointCloud.length === 0) {
                        throw new Error('Failed to generate point cloud');
                    }
                    this.debugLog(`‚úÖ Point cloud generated: ${pointCloud.length} points`, 'info');
                    
                    // Step 4: Create mesh
                    await this.updateProgress('Generating mesh...', 70);
                    this.debugLog('üî∫ Creating triangular mesh', 'step');
                    const mesh = this.createMeshFromPointCloud(pointCloud);
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Failed to create mesh');
                    }
                    this.debugLog(`‚úÖ Mesh created: ${mesh.vertices.length} vertices, ${mesh.faces.length} faces`, 'info');
                    
                    // Step 5: Optimize for 3D printing
                    await this.updateProgress('Optimizing for 3D printing...', 85);
                    this.debugLog('‚öôÔ∏è Optimizing mesh for 3D printing', 'step');
                    const optimizedMesh = this.optimizeForPrinting(mesh);
                    
                    if (!optimizedMesh || !optimizedMesh.vertices || !optimizedMesh.faces) {
                        throw new Error('Failed to optimize mesh');
                    }
                    this.debugLog(`‚úÖ Mesh optimized: ${optimizedMesh.vertices.length} vertices, ${optimizedMesh.faces.length} faces`, 'info');
                    
                    // Step 6: Generate STL
                    await this.updateProgress('Creating STL file...', 95);
                    this.debugLog('üìÑ Generating STL file', 'step');
                    const stlContent = this.generateAdvancedSTL(optimizedMesh);
                    
                    if (!stlContent) {
                        throw new Error('Failed to generate STL');
                    }
                    
                    const endTime = performance.now();
                    const processTime = ((endTime - startTime) / 1000).toFixed(2);
                    this.debugLog(`‚úÖ STL generated successfully in ${processTime}s`, 'info');
                    
                    await this.updateProgress('Complete!', 100);
                    this.updateDebugStats('Complete', '--', `${processTime}s`);
                    this.finalize3DModel(stlContent);
                    
                } catch (error) {
                    const endTime = performance.now();
                    const processTime = ((endTime - startTime) / 1000).toFixed(2);
                    
                    this.debugLog(`‚ùå PROCESSING FAILED: ${error.message}`, 'error');
                    this.debugLog(`üìä Failed after ${processTime}s`, 'error');
                    
                    if (error.stack) {
                        this.debugLog(`üìã Stack trace: ${error.stack}`, 'error');
                    }
                    
                    console.error('Processing error details:', error);
                    console.error('Error stack:', error.stack);
                    
                    alert(`Error processing image: ${error.message}. Check debug panel for details.`);
                    this.elements.processing.classList.add('hidden');
                    this.elements.processBtn.disabled = false;
                    this.updateDebugStats('Failed', '--', `${processTime}s`);
                }
            }

            async updateProgress(status, progress) {
                this.elements.processingStatus.textContent = status;
                this.elements.progressFill.style.width = progress + '%';
                await this.delay(800); // Realistic processing time
            }

            async prepareImageForProcessing() {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = this.elements.photoPreview;
                    
                    // Resize image for processing (smaller = faster)
                    const maxSize = 512;
                    let { width, height } = img;
                    
                    if (width > height) {
                        if (width > maxSize) {
                            height = (height * maxSize) / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = (width * maxSize) / height;
                            height = maxSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    const imageData = ctx.getImageData(0, 0, width, height);
                    resolve({ data: imageData, width, height });
                });
            }

            async estimateDepth(imageData) {
                this.debugLog('üîç Starting advanced depth estimation', 'step');
                const { data, width, height } = imageData;
                const depthMap = new Float32Array(width * height);
                
                // Step 1: Convert to grayscale and calculate gradients
                this.debugLog('üìä Calculating image gradients', 'info');
                const grayscale = new Float32Array(width * height);
                const gradientX = new Float32Array(width * height);
                const gradientY = new Float32Array(width * height);
                
                // Convert to grayscale and calculate gradients
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        const pixelIdx = idx * 4;
                        
                        // Improved grayscale conversion (luminance-based)
                        const r = data.data[pixelIdx];
                        const g = data.data[pixelIdx + 1];
                        const b = data.data[pixelIdx + 2];
                        grayscale[idx] = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // Calculate gradients (Sobel operators)
                        if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                            // Sobel X gradient
                            const gx = (-1 * grayscale[(y-1)*width + (x-1)]) + 
                                      (1 * grayscale[(y-1)*width + (x+1)]) +
                                      (-2 * grayscale[y*width + (x-1)]) + 
                                      (2 * grayscale[y*width + (x+1)]) +
                                      (-1 * grayscale[(y+1)*width + (x-1)]) + 
                                      (1 * grayscale[(y+1)*width + (x+1)]);
                            
                            // Sobel Y gradient  
                            const gy = (-1 * grayscale[(y-1)*width + (x-1)]) + 
                                      (-2 * grayscale[(y-1)*width + x]) +
                                      (-1 * grayscale[(y-1)*width + (x+1)]) +
                                      (1 * grayscale[(y+1)*width + (x-1)]) + 
                                      (2 * grayscale[(y+1)*width + x]) +
                                      (1 * grayscale[(y+1)*width + (x+1)]);
                            
                            gradientX[idx] = gx / 8.0;
                            gradientY[idx] = gy / 8.0;
                        }
                    }
                }
                
                // Step 2: Enhanced depth estimation using multiple cues
                this.debugLog('üéØ Computing depth from multiple visual cues', 'info');
                for (let y = 2; y < height - 2; y++) {
                    for (let x = 2; x < width - 2; x++) {
                        const idx = y * width + x;
                        let depth = 0;
                        
                        // Cue 1: Brightness-based depth (improved)
                        const brightness = grayscale[idx];
                        const normalizedBrightness = brightness / 255.0;
                        
                        // Cue 2: Gradient magnitude (edges suggest depth discontinuities)
                        const gradMagnitude = Math.sqrt(gradientX[idx] * gradientX[idx] + gradientY[idx] * gradientY[idx]);
                        const normalizedGrad = Math.min(gradMagnitude / 100.0, 1.0);
                        
                        // Cue 3: Local contrast analysis
                        let localContrast = 0;
                        let neighborCount = 0;
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nIdx = (y + dy) * width + (x + dx);
                                if (nIdx >= 0 && nIdx < grayscale.length) {
                                    localContrast += Math.abs(grayscale[idx] - grayscale[nIdx]);
                                    neighborCount++;
                                }
                            }
                        }
                        localContrast = neighborCount > 0 ? localContrast / neighborCount / 255.0 : 0;
                        
                        // Cue 4: Shape-from-shading using gradient direction
                        const gradientAngle = Math.atan2(gradientY[idx], gradientX[idx]);
                        const lightDirection = Math.PI / 4; // Assume light from top-left
                        const shadingFactor = Math.cos(gradientAngle - lightDirection) * 0.5 + 0.5;
                        
                        // Combine depth cues with weights
                        const brightnessDepth = (255 - brightness) / 255.0; // Darker = closer
                        const contrastDepth = localContrast * 2.0; // High contrast = edges = depth changes
                        const gradientDepth = normalizedGrad * 1.5; // Edges suggest depth
                        const shadingDepth = shadingFactor * 0.8; // Shading suggests 3D form
                        
                        // Weighted combination
                        depth = (brightnessDepth * 0.4) + 
                               (contrastDepth * 0.3) + 
                               (gradientDepth * 0.2) + 
                               (shadingDepth * 0.1);
                        
                        // Enhance depth range and add some baseline
                        depth = Math.pow(depth, 0.8) * 1.2 + 0.1; // Power function for better distribution
                        depth = Math.max(0.1, Math.min(1.0, depth));
                        
                        depthMap[idx] = depth;
                    }
                }
                
                this.debugLog('üîß Applying advanced filtering', 'info');
                
                // Step 3: Apply bilateral filtering to preserve edges while smoothing
                const filteredDepth = this.bilateralFilter(depthMap, grayscale, width, height);
                
                // Step 4: Edge-preserving smoothing
                const finalDepth = this.edgePreservingSmooth(filteredDepth, gradientX, gradientY, width, height);
                
                this.debugLog(`‚úÖ Advanced depth estimation complete: range ${Math.min(...finalDepth).toFixed(3)} to ${Math.max(...finalDepth).toFixed(3)}`, 'info');
                
                return finalDepth;
            }

            bilateralFilter(depthMap, grayscale, width, height) {
                this.debugLog('üé® Applying bilateral filter for edge preservation', 'info');
                const filtered = new Float32Array(depthMap.length);
                const spatialSigma = 3.0;
                const intensitySigma = 30.0;
                const kernelSize = 5;
                const kernelRadius = Math.floor(kernelSize / 2);
                
                for (let y = kernelRadius; y < height - kernelRadius; y++) {
                    for (let x = kernelRadius; x < width - kernelRadius; x++) {
                        const centerIdx = y * width + x;
                        const centerIntensity = grayscale[centerIdx];
                        
                        let weightSum = 0;
                        let depthSum = 0;
                        
                        for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {
                            for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {
                                const neighborIdx = (y + ky) * width + (x + kx);
                                const neighborIntensity = grayscale[neighborIdx];
                                
                                // Spatial weight (Gaussian)
                                const spatialDist = Math.sqrt(kx * kx + ky * ky);
                                const spatialWeight = Math.exp(-(spatialDist * spatialDist) / (2 * spatialSigma * spatialSigma));
                                
                                // Intensity weight (preserve edges)
                                const intensityDist = Math.abs(centerIntensity - neighborIntensity);
                                const intensityWeight = Math.exp(-(intensityDist * intensityDist) / (2 * intensitySigma * intensitySigma));
                                
                                const totalWeight = spatialWeight * intensityWeight;
                                weightSum += totalWeight;
                                depthSum += depthMap[neighborIdx] * totalWeight;
                            }
                        }
                        
                        filtered[centerIdx] = weightSum > 0 ? depthSum / weightSum : depthMap[centerIdx];
                    }
                }
                
                // Copy borders
                for (let i = 0; i < depthMap.length; i++) {
                    const y = Math.floor(i / width);
                    const x = i % width;
                    if (y < kernelRadius || y >= height - kernelRadius || 
                        x < kernelRadius || x >= width - kernelRadius) {
                        filtered[i] = depthMap[i];
                    }
                }
                
                return filtered;
            }

            edgePreservingSmooth(depthMap, gradientX, gradientY, width, height) {
                this.debugLog('‚ú® Applying edge-preserving smoothing', 'info');
                const smoothed = new Float32Array(depthMap.length);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        // Calculate edge strength
                        const edgeStrength = Math.sqrt(gradientX[idx] * gradientX[idx] + gradientY[idx] * gradientY[idx]);
                        const edgeThreshold = 20.0;
                        
                        if (edgeStrength > edgeThreshold) {
                            // Strong edge - preserve original depth
                            smoothed[idx] = depthMap[idx];
                        } else {
                            // Smooth area - apply 3x3 Gaussian
                            let sum = 0;
                            let weightSum = 0;
                            const weights = [
                                [1, 2, 1],
                                [2, 4, 2], 
                                [1, 2, 1]
                            ];
                            
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const nIdx = (y + ky) * width + (x + kx);
                                    const weight = weights[ky + 1][kx + 1];
                                    sum += depthMap[nIdx] * weight;
                                    weightSum += weight;
                                }
                            }
                            
                            smoothed[idx] = sum / weightSum;
                        }
                    }
                }
                
                // Copy borders
                for (let y = 0; y < height; y++) {
                    smoothed[y * width] = depthMap[y * width]; // Left edge
                    smoothed[y * width + width - 1] = depthMap[y * width + width - 1]; // Right edge
                }
                for (let x = 0; x < width; x++) {
                    smoothed[x] = depthMap[x]; // Top edge
                    smoothed[(height - 1) * width + x] = depthMap[(height - 1) * width + x]; // Bottom edge
                }
                
                return smoothed;
            }

            calculateVariance(values) {
                const mean = values.reduce((a, b) => a + b) / values.length;
                return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            }

            smoothDepthMap(depthMap, width, height) {
                const smoothed = new Float32Array(depthMap.length);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        
                        // 3x3 average filter
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += depthMap[(y + dy) * width + (x + dx)];
                            }
                        }
                        smoothed[idx] = sum / 9;
                    }
                }
                
                return smoothed;
            }

            generatePointCloud(imageData, depthMap) {
                this.debugLog('‚òÅÔ∏è Generating enhanced point cloud with improved spacing', 'step');
                const { width, height } = imageData;
                const points = [];
                
                // Enhanced point cloud generation with better scaling
                const skipFactor = 3; // Process every 3rd pixel for better performance but still good detail
                const scaleX = 30; // Wider range for better proportions
                const scaleY = 30;
                const scaleZ = 15; // Height scaling
                
                let pointCount = 0;
                for (let y = 0; y < height; y += skipFactor) {
                    for (let x = 0; x < width; x += skipFactor) {
                        const idx = y * width + x;
                        const depth = depthMap[idx];
                        
                        // Improved 3D coordinate mapping
                        const worldX = ((x / width) - 0.5) * scaleX; // Center around 0
                        const worldY = (0.5 - (y / height)) * scaleY; // Flip Y and center
                        const worldZ = depth * scaleZ; // Scale depth appropriately
                        
                        // Get color from original image
                        const pixelIdx = idx * 4;
                        const r = imageData.data.data[pixelIdx] || 128;
                        const g = imageData.data.data[pixelIdx + 1] || 128;
                        const b = imageData.data.data[pixelIdx + 2] || 128;
                        
                        points.push({
                            x: worldX,
                            y: worldY,
                            z: worldZ,
                            color: { r, g, b },
                            originalX: x,
                            originalY: y,
                            depth: depth
                        });
                        pointCount++;
                    }
                }
                
                this.debugLog(`‚úÖ Generated ${pointCount} 3D points with improved scaling`, 'info');
                this.debugLog(`üìê Scale factors: X=${scaleX}, Y=${scaleY}, Z=${scaleZ}`, 'info');
                
                return points;
            }

            createMeshFromPointCloud(pointCloud) {
                try {
                    this.debugLog('üî∫ Starting mesh creation from point cloud', 'step');
                    const vertices = [];
                    const faces = [];
                    
                    // Determine grid dimensions
                    const totalPoints = pointCloud.length;
                    const gridWidth = Math.floor(Math.sqrt(totalPoints));
                    const gridHeight = Math.floor(totalPoints / gridWidth);
                    
                    this.debugLog(`üìê Grid dimensions: ${gridWidth}x${gridHeight} (${totalPoints} total points)`, 'info');
                    
                    // Add all vertices
                    pointCloud.forEach(point => {
                        vertices.push({
                            x: point.x,
                            y: point.y,
                            z: point.z,
                            color: point.color
                        });
                    });
                    
                    this.debugLog(`‚úÖ Added ${vertices.length} vertices to mesh`, 'info');
                    
                    // Create triangular faces
                    let faceCount = 0;
                    for (let row = 0; row < gridHeight - 1; row++) {
                        for (let col = 0; col < gridWidth - 1; col++) {
                            const i = row * gridWidth + col;
                            
                            // Skip if indices are out of bounds
                            if (i + gridWidth + 1 >= vertices.length) continue;
                            
                            const topLeft = i;
                            const topRight = i + 1;
                            const bottomLeft = i + gridWidth;
                            const bottomRight = i + gridWidth + 1;
                            
                            // Ensure all indices are valid
                            if (topLeft < vertices.length && 
                                topRight < vertices.length && 
                                bottomLeft < vertices.length && 
                                bottomRight < vertices.length) {
                                
                                // Create two triangles per quad
                                faces.push([topLeft, topRight, bottomLeft]);
                                faces.push([topRight, bottomRight, bottomLeft]);
                                faceCount += 2;
                            }
                        }
                    }
                    
                    this.debugLog(`‚úÖ Created ${faceCount} triangular faces`, 'info');
                    
                    if (vertices.length === 0 || faces.length === 0) {
                        throw new Error('No valid mesh geometry created');
                    }
                    
                    const result = { vertices, faces };
                    this.debugLog(`üéØ Mesh creation complete: ${result.vertices.length} vertices, ${result.faces.length} faces`, 'info');
                    
                    return result;
                    
                } catch (error) {
                    this.debugLog(`‚ùå Error in createMeshFromPointCloud: ${error.message}`, 'error');
                    throw error;
                }
            }

            optimizeForPrinting(mesh) {
                try {
                    console.log('Starting optimization...');
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Invalid mesh data for optimization');
                    }
                    
                    // Store the mesh for 3D preview (before adding base)
                    this.currentMesh = {
                        vertices: [...mesh.vertices], // Create copy
                        faces: [...mesh.faces] // Create copy
                    };
                    
                    // Add base thickness for printability
                    const baseThickness = 2.0;
                    const optimizedVertices = [];
                    
                    // Find minimum Z value
                    const zValues = mesh.vertices.map(v => v.z).filter(z => !isNaN(z));
                    if (zValues.length === 0) {
                        throw new Error('No valid Z coordinates found');
                    }
                    
                    const minZ = Math.min(...zValues);
                    console.log(`Min Z value: ${minZ}`);
                    
                    // Adjust all vertices and add base
                    mesh.vertices.forEach((vertex, index) => {
                        if (!vertex || typeof vertex.x !== 'number' || typeof vertex.y !== 'number' || typeof vertex.z !== 'number') {
                            console.warn(`Invalid vertex at index ${index}:`, vertex);
                            return; // Skip invalid vertices
                        }
                        
                        // Elevate surface
                        optimizedVertices.push({
                            x: vertex.x,
                            y: vertex.y,
                            z: vertex.z - minZ + baseThickness,
                            color: vertex.color || { r: 128, g: 128, b: 128 }
                        });
                    });
                    
                    // Add base vertices
                    mesh.vertices.forEach((vertex, index) => {
                        if (!vertex || typeof vertex.x !== 'number' || typeof vertex.y !== 'number' || typeof vertex.z !== 'number') {
                            return; // Skip invalid vertices
                        }
                        
                        optimizedVertices.push({
                            x: vertex.x,
                            y: vertex.y,
                            z: 0,
                            color: vertex.color || { r: 128, g: 128, b: 128 }
                        });
                    });
                    
                    // Copy original faces
                    const optimizedFaces = [...mesh.faces];
                    const validVertexCount = mesh.vertices.filter(v => v && typeof v.x === 'number').length;
                    
                    // Add base faces (flipped normals) - only if we have valid vertices
                    if (validVertexCount > 0) {
                        mesh.faces.forEach(face => {
                            if (face && Array.isArray(face) && face.length === 3) {
                                // Check if face indices are valid
                                if (face[0] < validVertexCount && face[1] < validVertexCount && face[2] < validVertexCount) {
                                    optimizedFaces.push([
                                        face[0] + validVertexCount,
                                        face[2] + validVertexCount,
                                        face[1] + validVertexCount
                                    ]);
                                }
                            }
                        });
                    }
                    
                    const result = {
                        vertices: optimizedVertices,
                        faces: optimizedFaces
                    };
                    
                    console.log(`Optimization complete: ${result.vertices.length} vertices, ${result.faces.length} faces`);
                    
                    if (result.vertices.length === 0 || result.faces.length === 0) {
                        throw new Error('Optimization resulted in empty mesh');
                    }
                    
                    return result;
                    
                } catch (error) {
                    console.error('Error in optimizeForPrinting:', error);
                    throw error;
                }
            }

            generateAdvancedSTL(mesh) {
                try {
                    console.log('Generating STL...');
                    
                    if (!mesh || !mesh.vertices || !mesh.faces) {
                        throw new Error('Invalid mesh data for STL generation');
                    }
                    
                    let stl = 'solid PhotoTo3DModel\n';
                    let validFaceCount = 0;
                    
                    mesh.faces.forEach((face, faceIndex) => {
                        try {
                            if (!face || !Array.isArray(face) || face.length !== 3) {
                                console.warn(`Invalid face at index ${faceIndex}:`, face);
                                return;
                            }
                            
                            const [i1, i2, i3] = face;
                            
                            // Check if vertex indices are valid
                            if (i1 >= mesh.vertices.length || i2 >= mesh.vertices.length || i3 >= mesh.vertices.length ||
                                i1 < 0 || i2 < 0 || i3 < 0) {
                                console.warn(`Invalid vertex indices in face ${faceIndex}: [${i1}, ${i2}, ${i3}]`);
                                return;
                            }
                            
                            const v1 = mesh.vertices[i1];
                            const v2 = mesh.vertices[i2];
                            const v3 = mesh.vertices[i3];
                            
                            // Validate vertices
                            if (!v1 || !v2 || !v3 ||
                                typeof v1.x !== 'number' || typeof v1.y !== 'number' || typeof v1.z !== 'number' ||
                                typeof v2.x !== 'number' || typeof v2.y !== 'number' || typeof v2.z !== 'number' ||
                                typeof v3.x !== 'number' || typeof v3.y !== 'number' || typeof v3.z !== 'number') {
                                console.warn(`Invalid vertices in face ${faceIndex}:`, { v1, v2, v3 });
                                return;
                            }
                            
                            // Calculate normal vector
                            const normal = this.calculateNormal(v1, v2, v3);
                            
                            // Validate normal
                            if (!normal || typeof normal.x !== 'number' || typeof normal.y !== 'number' || typeof normal.z !== 'number') {
                                console.warn(`Invalid normal for face ${faceIndex}:`, normal);
                                return;
                            }
                            
                            stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                            stl += '    outer loop\n';
                            stl += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                            stl += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                            stl += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                            stl += '    endloop\n';
                            stl += '  endfacet\n';
                            
                            validFaceCount++;
                            
                        } catch (faceError) {
                            console.warn(`Error processing face ${faceIndex}:`, faceError);
                        }
                    });
                    
                    stl += 'endsolid PhotoTo3DModel\n';
                    
                    console.log(`STL generated with ${validFaceCount} valid faces`);
                    
                    if (validFaceCount === 0) {
                        throw new Error('No valid faces generated in STL');
                    }
                    
                    return stl;
                    
                } catch (error) {
                    console.error('Error in generateAdvancedSTL:', error);
                    throw error;
                }
            }

            calculateNormal(v1, v2, v3) {
                try {
                    // Calculate cross product for normal vector
                    const u = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
                    const v = { x: v3.x - v1.x, y: v3.y - v1.y, z: v3.z - v1.z };
                    
                    const normal = {
                        x: u.y * v.z - u.z * v.y,
                        y: u.z * v.x - u.x * v.z,
                        z: u.x * v.y - u.y * v.x
                    };
                    
                    // Normalize
                    const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (length > 0.0001) { // Avoid division by very small numbers
                        normal.x /= length;
                        normal.y /= length;
                        normal.z /= length;
                    } else {
                        // Default normal if calculation fails
                        normal.x = 0;
                        normal.y = 0;
                        normal.z = 1;
                    }
                    
                    // Ensure normal values are valid numbers
                    if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)) {
                        return { x: 0, y: 0, z: 1 }; // Default normal
                    }
                    
                    return normal;
                    
                } catch (error) {
                    console.warn('Error calculating normal:', error);
                    return { x: 0, y: 0, z: 1 }; // Default normal
                }
            }

            finalize3DModel(stlContent) {
                const blob = new Blob([stlContent], { type: 'application/octet-stream' });
                this.modelBlob = blob;
                
                // Calculate realistic metrics
                const triangleCount = (stlContent.match(/facet normal/g) || []).length;
                const fileSize = Math.round(blob.size / 1024);
                const printTime = Math.max(30, Math.floor(triangleCount / 50)); // More realistic print time
                const fileName = `photo_3d_${Date.now()}.stl`;
                
                this.elements.fileName.textContent = fileName;
                this.elements.fileSize.textContent = fileSize + ' KB';
                this.elements.triangleCount.textContent = triangleCount.toLocaleString();
                this.elements.printTime.textContent = printTime + ' min';
                
                this.elements.processing.classList.add('hidden');
                this.elements.result.classList.remove('hidden');
                this.elements.processBtn.disabled = false;
                
                // Initialize 3D preview
                this.init3DPreview();
            }

            init3DPreview() {
                this.debugLog('üé¨ Initializing 3D preview', 'step');
                const container = this.elements.modelPreview;
                
                // Clear previous preview
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                
                try {
                    // Create Three.js scene
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0xf0f0f0);
                    this.debugLog('‚úÖ Three.js scene created', 'info');
                    
                    // Create camera
                    this.camera = new THREE.PerspectiveCamera(
                        75, 
                        container.clientWidth / container.clientHeight, 
                        0.1, 
                        1000
                    );
                    this.debugLog('‚úÖ Camera created', 'info');
                    
                    // Create renderer
                    this.renderer = new THREE.WebGLRenderer({ antialias: true });
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    container.appendChild(this.renderer.domElement);
                    this.debugLog('‚úÖ WebGL renderer created', 'info');
                    
                    // Add lights
                    this.addLights();
                    
                    // Create 3D model from mesh data
                    this.create3DModel();
                    
                    // Add controls
                    this.addOrbitControls();
                    
                    // Position camera
                    this.resetCamera();
                    
                    // Start render loop
                    this.animate();
                    
                    // Hide loading indicator
                    this.elements.previewLoading.style.display = 'none';
                    this.debugLog('üéØ 3D preview initialization complete', 'info');
                    
                } catch (error) {
                    this.debugLog(`‚ùå 3D preview initialization failed: ${error.message}`, 'error');
                    this.elements.previewLoading.innerHTML = `<p style="color: red;">3D Preview Error: ${error.message}</p>`;
                }
            }

            addLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (main)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                
                // Point light (fill)
                const pointLight = new THREE.PointLight(0xffffff, 0.3, 100);
                pointLight.position.set(-10, -10, 10);
                this.scene.add(pointLight);
            }

            create3DModel() {
                if (!this.currentMesh) return;
                
                // Create geometry from mesh data
                const geometry = new THREE.BufferGeometry();
                
                // Convert vertices to flat array
                const vertices = [];
                const normals = [];
                
                this.currentMesh.faces.forEach(face => {
                    const v1 = this.currentMesh.vertices[face[0]];
                    const v2 = this.currentMesh.vertices[face[1]];
                    const v3 = this.currentMesh.vertices[face[2]];
                    
                    // Add vertices
                    vertices.push(v1.x, v1.y, v1.z);
                    vertices.push(v2.x, v2.y, v2.z);
                    vertices.push(v3.x, v3.y, v3.z);
                    
                    // Calculate normal
                    const normal = this.calculateNormal(v1, v2, v3);
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                    normals.push(normal.x, normal.y, normal.z);
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                // Create materials
                const solidMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4CAF50,
                    side: THREE.DoubleSide
                });
                
                const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x2196F3,
                    wireframe: true,
                    side: THREE.DoubleSide
                });
                
                // Create mesh
                this.model3D = new THREE.Mesh(geometry, solidMaterial);
                this.model3D.castShadow = true;
                this.model3D.receiveShadow = true;
                
                // Store materials for switching
                this.model3D.userData.solidMaterial = solidMaterial;
                this.model3D.userData.wireframeMaterial = wireframeMaterial;
                
                this.scene.add(this.model3D);
                
                // Add ground plane
                this.addGroundPlane();
            }

            addGroundPlane() {
                const planeGeometry = new THREE.PlaneGeometry(50, 50);
                const planeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.3
                });
                
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -5;
                plane.receiveShadow = true;
                
                this.scene.add(plane);
            }

            addOrbitControls() {
                // Simple orbit controls implementation
                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                let targetRotationX = 0;
                let targetRotationY = 0;
                let rotationX = 0;
                let rotationY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                // Touch controls for mobile
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        isMouseDown = true;
                        mouseX = e.touches[0].clientX;
                        mouseY = e.touches[0].clientY;
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (!isMouseDown || e.touches.length !== 1) return;
                    e.preventDefault();
                    
                    const deltaX = e.touches[0].clientX - mouseX;
                    const deltaY = e.touches[0].clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                });
                
                canvas.addEventListener('touchend', () => {
                    isMouseDown = false;
                });
                
                // Zoom with wheel/pinch
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoom = e.deltaY * 0.01;
                    this.camera.position.z = Math.max(5, Math.min(50, this.camera.position.z + zoom));
                });
                
                // Store rotation update function
                this.updateRotation = () => {
                    rotationX += (targetRotationX - rotationX) * 0.1;
                    rotationY += (targetRotationY - rotationY) * 0.1;
                    
                    if (this.model3D) {
                        this.model3D.rotation.x = rotationX;
                        this.model3D.rotation.y = rotationY;
                    }
                };
            }

            animate() {
                if (!this.renderer || !this.scene || !this.camera) return;
                
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                if (this.updateRotation) {
                    this.updateRotation();
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            setWireframeMode(wireframe) {
                if (!this.model3D) return;
                
                if (wireframe) {
                    this.model3D.material = this.model3D.userData.wireframeMaterial;
                    this.elements.wireframeBtn.classList.add('active');
                    this.elements.solidBtn.classList.remove('active');
                } else {
                    this.model3D.material = this.model3D.userData.solidMaterial;
                    this.elements.wireframeBtn.classList.remove('active');
                    this.elements.solidBtn.classList.add('active');
                }
            }

            resetCamera() {
                if (!this.camera) return;
                
                this.camera.position.set(15, 15, 15);
                this.camera.lookAt(0, 0, 0);
                
                if (this.model3D) {
                    this.model3D.rotation.x = 0.3;
                    this.model3D.rotation.y = 0.5;
                }
            }

            generate3DFile() {
                // This method is now replaced by the advanced processing above
                // Keeping for backwards compatibility if needed
            }

            generateSTLContent() {
                // Generate a simple pyramid STL for demo
                // In a real app, this would be the actual 3D reconstruction
                let stl = 'solid PhotoTo3DModel\n';
                
                // Simple pyramid faces
                const faces = [
                    // Base
                    [[0, 0, 0], [10, 0, 0], [5, 10, 0]],
                    [[0, 0, 0], [5, 10, 0], [10, 0, 0]],
                    // Sides
                    [[0, 0, 0], [5, 5, 10], [10, 0, 0]],
                    [[10, 0, 0], [5, 5, 10], [5, 10, 0]],
                    [[5, 10, 0], [5, 5, 10], [0, 0, 0]]
                ];
                
                faces.forEach(face => {
                    stl += '  facet normal 0 0 1\n';
                    stl += '    outer loop\n';
                    face.forEach(vertex => {
                        stl += `      vertex ${vertex[0]} ${vertex[1]} ${vertex[2]}\n`;
                    });
                    stl += '    endloop\n';
                    stl += '  endfacet\n';
                });
                
                stl += 'endsolid PhotoTo3DModel\n';
                return stl;
            }

            downloadModel() {
                if (this.modelBlob) {
                    const url = URL.createObjectURL(this.modelBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.elements.fileName.textContent;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            resetApp() {
                this.currentImage = null;
                this.modelBlob = null;
                this.currentMesh = null;
                
                // Clean up 3D scene
                if (this.renderer) {
                    this.renderer.dispose();
                    this.renderer = null;
                }
                this.scene = null;
                this.camera = null;
                this.model3D = null;
                
                this.elements.photoPreview.classList.add('hidden');
                this.elements.placeholder.classList.remove('hidden');
                this.elements.photoContainer.classList.remove('has-image');
                this.elements.processBtn.classList.add('hidden');
                this.elements.newPhotoBtn.classList.add('hidden');
                this.elements.processing.classList.add('hidden');
                this.elements.result.classList.add('hidden');
                this.elements.progressFill.style.width = '0%';
                this.elements.fileInput.value = '';
                this.elements.previewLoading.style.display = 'block';
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker registered:', registration);
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new PhotoTo3DApp();
        });

        // Add to home screen prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button after a delay
            setTimeout(() => {
                if (confirm('Add Photo to 3D to your home screen for easy access?')) {
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then((choiceResult) => {
                        deferredPrompt = null;
                    });
                }
            }, 3000);
        });
    </script>
</body>
</html>
